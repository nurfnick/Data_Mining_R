---
title: "Earthquakes 2021"
author: "Nicholas Jacob"
date: "8/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rvest)
library(tidyverse)

url = 'https://en.wikipedia.org/wiki/List_of_earthquakes_in_2021'
```

## Scrapping Wikipedia

First I am going to gather the data from wikipedia with the `rvest` library.

```{r gatherhtml}
html <- read_html(url)
```
Let's take a look at the html and see what we have gathered.

```{r veiwhtml}
html[1]
```
Look's like we got something.  Let's see if we can extract the tables from the webpage.

```{r tableshtml}
tables <- html %>%
  html_table(header = TRUE)

length(tables)
```
That was a lot of tables!  Let's dig in and see if we can extract the monthly ones.  I think the seventh one is January's.
```{r}


tables[[7]][-1,]
```
Let's now create our eventual final dataframe and make certain we add a column highlighting what month this happened in.

```{r}
jan <- tables[[7]][-1,]

df <- jan %>% add_column(Month = 'January')


```
Let's automate the rest.  It is currently August so there is only 8 months of data.

```{r}
monthlist = c('January','February','March','April','May','June','July','August','September')
counter = c(2:9)

for (number in counter){
  newtable <- tables[[5+2*number]][-1,] #the minus one is to get rid of the title of the columns 
  newtable <- newtable %>% add_column(Month = monthlist[number])
  df <- bind_rows(df,newtable)
}
```
```{r}
head(df)
```
I am going to need to do some cleaning now that I have gathered the data.  In the *Date* column there is a reference hyperlink in square brackets.  Let's get rid of that and rename it *Day*
```{r cleanDay}
df <- df %>%
  mutate(
    Day = str_remove_all(Date,pattern = "\\[*[0-9]*\\]")
  )
  
```

Next I'd like to change all the casualty entries from *NA* to zero.

```{r cleanCasualties}
df <- df %>%
  mutate(
    Deaths = str_replace_all(Casualties...7,"\\-","0"),
    Injuries = str_replace_all(Casualties...8,"\\-","0")
  )
```

They were not actually `NA` but were `-`.  Tricky!

Let's continue looking to extract some information about country and location
```{r}
df<- df %>%
  mutate(
    Offshore = str_detect(`Country and location`,"offshore"),
    Country = str_extract(`Country and location`,'[A-z]+')
  )


```


A couple of these are wrong, I'll fix the obvious ones and come back if I see others I missed later.

```{r}
df <- df %>%
  mutate(
    Country = replace(Country, Country == 'United','United States'),
    Country = replace(Country, Country == 'South', 'South Georgia'),
    Country = replace(Country, Country == 'Papua','Papua New Guinea')
  )

```


```{r}
df <- df %>%
  mutate(
    Country = replace(Country, str_detect(`Country and location`,'New Zealand'),'New Zealand'),
    Country = replace(Country, str_detect(`Country and location`,'New Cal'),'New Caledonia')
                 )
```

```{r}
df <- df %>%
  rename(Depth = 'Depth (km)')
```
Okay I think I have extracted all the info I am going to.  I'll clean up the dataset and organize it.
```{r organize}
df <- df %>%
  select(c(Month,Day,Country,Deaths,Injuries,Mw,Depth,MMI,Offshore))
```
```{r}
df <- df %>%
  mutate(
    Deaths = str_remove_all(Deaths,","),
    Injuries = str_remove_all(Injuries, ",")
  )
```

```{r}
df <- df %>%
  mutate(Deaths = as.integer(Deaths),
         Injuries = as.integer(Injuries),
         Depth = as.numeric(Depth),
         Day = as.integer(Day),
         Mw = as.numeric(Mw))

```
```{r}
df <- df %>%
  drop_na()
```
## Ready For EDA

```{r}
df %>%
  summarize(Average_Deaths = mean(Deaths),
            Average_Injuries = mean(Injuries))
```
```{r}
df %>% summarize_if(is.numeric, c(Mean = mean,Median = median))
```
```{r}
library(corrr)
df_cor <- df %>%
  select(c(Day,Injuries,Deaths,Mw,Depth)) %>%
  correlate()

df_cor
```
Here we see that the correlation looks great!
```{r}
stretch(df_cor) %>%
  ggplot(aes(x=x, y=y, fill=r, label = round(r,2))) +
  geom_tile()
```

```{r}
df %>%
  group_by(MMI) %>%
  summarize_if(is.numeric,mean)
```

```{r}
summary(df$Day)
```

```{r}
ggplot(data = df, aes(y= Day,color = Month)) +
  geom_boxplot()

```

```{r}
ggplot(df, aes(x= Day)) +
  geom_histogram()
```

```{r}
ggplot(df, aes(x= Injuries))+
  geom_histogram(bins = 100)
```

```{r}
ggplot(df, aes(x= MMI))+
  geom_bar(aes(fill = Month), position = 'fill')
```

```{r}
ggplot(df, aes(x= Injuries, y= Deaths)) +
  geom_jitter(aes(color = MMI))
```

```{r}
library(GGally)

df1 <- df %>% 
  select(-Country,-Month,-Day) 


ggpairs(df1, aes(color = Offshore))
```

```{r}
library(ggmosaic)

ggplot(data = df)+
  geom_mosaic( aes(x = product(MMI,Month),fill = Offshore),na.rm = TRUE) 
```

```{r}
ggplot(df,aes(sample = Injuries)) +
  geom_qq() +
  geom_qq_line()
```

```{r, twoway with dplyr}
df %>%
  count(Offshore, MMI) %>%
  spread(MMI,n, fill = 0)
```

```{r proportion table}
df %>%
  group_by(Offshore) %>%
  summarise(Frequency = n()) %>%
  mutate(Proportion = Frequency/sum(Frequency))

```

## Decision Trees

Moving on to decision trees and classification.  The variable you are predicting must be a factor!

```{r make offshore a factor}
df <- df %>% mutate(
  Offshore = factor(Offshore == TRUE, levels = c(TRUE, FALSE),
                    labels = c('offshore','on land' ))
)
```

```{r}
library(rpart)
library(rpart.plot)

tree <- rpart(Offshore ~.,data = df)
tree
```
```{r tree viz}
rpart.plot(tree, extra = 2)
```

To make a prediction using the tree we have created, we pass *predict* the tree we have created and the dataset we want it to work on.

```{r}
pred <- predict(tree, df, type = "class")
head(pred)
```
Each has been classified into its category.  You can also recover the probabilities of the classification by dropping the *type = "class"*
```{r}
predict(tree, df) %>%
  head()
```
We see that the first earthquake has a 93% shot of being offshore.

Confusion table follows by using the classified data.

```{r}
confusion_table <- with(df, table(Offshore, pred))
confusion_table
```

I will now examine what happens if I withhold some of the data and do a cross validation.  I split the data into thirds for testing and training.
```{r}
library(caret)

inTrain <- createDataPartition(y = df$Month, p = .66, list = FALSE)
df_train <- df %>% slice(inTrain)
df_test <- df %>% slice(-inTrain)
```
```{r}
dim(df_train)
dim(df_test)
```

I will use the training set to build my model and then test it.  If you look at my original tree, the country is very important.  I am going to remove it from my tree and not allow that to be part of the decision tree (it was causing hell in me creating a tree!).
```{r}
tree_from_train <- rpart(Offshore ~.,data = subset(df_train, select=c( -Country)))
pred_test <- predict(tree_from_train, subset(df_test, select=c( -Country)), type = "class")
with(df_test, table(Offshore, pred_test))
```
Pretty decent job predicting on the withheld data!

I'll create a full tree next!  I only have ~150 data points so I won't have to chop it but if you have lots of data please do!  I left the code that does chop it `sample_n()` gives $n$ samples of the data



```{r}
df_no_Country <- subset(df, select=c( -Country))
tree_full <- sample_n(df_no_Country,100) %>% #only keeps 100 of the data points ()
  rpart(Offshore ~., data = ., control = rpart.control(minsplit = 2, cp = 0))

rpart.plot(tree_full, extra = 2, roundint=FALSE,
  box.palette = list( "Gn", "Bu")) # specify 2 colors
```

Holy cow that looks difficult to interpret!

I see now that I was supposed to withhold some data to test with.  I don't have access to that data, but I can do predictions on all the data.  Note the 100 above are perfectly classified so the 50 that are left are the only ones that could be mis-classified.

```{r}
pred_full <- predict(tree_full, df_no_Country, type = "class")
with(df, table(Offshore, pred_full))
```

Still not terrible but 7 mis-classified when originally on the training data there are no mis-classifications.  In any case you should see some over-fitting here.  High variance and low bias has caused over-fitting on the training.

```{r}
imp <- varImp(tree)
head(imp)

```
```{r}
imp %>% ggplot(aes(x = row.names(imp), weight = Overall)) +
  geom_bar()
```
```{r}
barplot(imp$Overall)
```
I am not satisfied with this way as I have no idea what *varimp* does, so I'll repeat this using a chi-squared test for significance.

```{r}
library(FSelector)

weights <- df %>% chi.squared(Offshore ~ ., data = .) %>%
  as_tibble(rownames = "feature") %>%
  arrange(desc(attr_importance))
weights

```
```{r}
ggplot(weights,
  aes(x = attr_importance, y = reorder(feature, attr_importance))) +
  geom_bar(stat = "identity") +
  xlab("Importance score") + ylab("Feature")
```




Another tree because I was playing around...
```{r}
tree1 <- rpart(MMI ~Offshore + Deaths + Mw,data = df, method = 'class')
tree1
```
```{r tree viz2}
rpart.plot(tree1, extra = 2)
```

If you want to implement C4.5 or C5.0, check out the examples [here](https://rpubs.com/kjmazidi/195428)
```{r}
tree
```
